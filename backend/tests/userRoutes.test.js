// tests/userRoutes.test.js
const request = require('supertest');
const app = require('../src/app');
const User = require('../src/models/user');
const cryptoUtils = require('../src/utils/cryptoUtils');
require('dotenv').config();

// --- Mock Dependencies ---
jest.mock('../src/models/user');

// Mock the service used by the controller triggered by the route
jest.mock('../src/services/bchService', () => ({
    generateAddress: jest.fn(),
    // Add other functions if other routes use them
}));
// Require the mocked service *after* jest.mock
const bchService = require('../src/services/bchService');

// Mock cryptoUtils (needed for verifying encryption)
jest.mock('../src/utils/cryptoUtils');

// Mock authMiddleware if needed for protected routes tested here
// jest.mock('../src/middlewares/authMiddleware', () => jest.fn((req, res, next) => {
//     req.user = { email: 'test@example.com', id: 'mockUserId' }; // Simulate authenticated user
//     next();
// }));

// --- End Mocks ---


describe('User Routes - POST /api/users/register', () => {
    beforeEach(() => {
        jest.clearAllMocks();
        User.findOne.mockReset();
        User.prototype.save = jest.fn(); // Mock save on prototype
        bchService.generateAddress.mockReset(); // Reset service mock calls
        cryptoUtils.encrypt.mockClear(); // Clear crypto mock calls
        cryptoUtils.decrypt.mockClear();
    });

    it('should register a new user successfully via the route', async () => {
        const userData = {
            email: 'route-test@example.com',
            // Note: The route now only expects 'email'. Mnemonic/path are generated by the service.
        };

        // Mock User.findOne to return null (user doesn't exist)
        User.findOne.mockResolvedValue(null);

        // Mock bchService.generateAddress response (this is called by the controller)
        const mockWalletDetails = {
            mnemonic: 'mock route mnemonic phrase',
            wif: 'cMockRouteWif',
            publicKey: 'mockRoutePublicKey',
            address: 'bchtest:qmockrouteaddress',
            derivationPath: "m/44'/145'/0'/0/0"
        };
        bchService.generateAddress.mockResolvedValue(mockWalletDetails);

        // Mock cryptoUtils.encrypt response (called by the controller)
        cryptoUtils.encrypt.mockImplementation((data, key) => `encrypted-${data.substring(0, 10)}`); // Simple mock implementation

        // Mock the save method response (called by the controller)
        const expectedSavedUser = {
            _id: 'mockRouteUserId',
            email: userData.email,
            encryptedMnemonic: `encrypted-${mockWalletDetails.mnemonic.substring(0, 10)}`,
            encryptedDerivationPath: `encrypted-${mockWalletDetails.derivationPath.substring(0, 10)}`,
            bchAddress: mockWalletDetails.address,
            createdAt: new Date(),
            updatedAt: new Date(),
        };
        User.prototype.save.mockResolvedValue(expectedSavedUser);


        const response = await request(app)
            .post('/api/users/register')
            .send(userData); // Send only the email

        // --- Assertions ---
        expect(response.statusCode).toBe(201);
        expect(response.body).toHaveProperty('email', userData.email);
        expect(response.body).toHaveProperty('_id', expectedSavedUser._id);
        expect(response.body).toHaveProperty('bchAddress', mockWalletDetails.address);
        expect(response.body).toHaveProperty('message', 'User registered successfully.');
        // Ensure sensitive data generated server-side is not returned
        expect(response.body).not.toHaveProperty('mnemonic');
        expect(response.body).not.toHaveProperty('wif');
        expect(response.body).not.toHaveProperty('encryptedMnemonic'); // Controller shouldn't return this
        expect(response.body).not.toHaveProperty('encryptedDerivationPath'); // Controller shouldn't return this


        // Verify underlying calls happened as expected
        expect(User.findOne).toHaveBeenCalledTimes(1);
        expect(User.findOne).toHaveBeenCalledWith({ email: userData.email });
        expect(bchService.generateAddress).toHaveBeenCalledTimes(1); // Service called by controller
        expect(cryptoUtils.encrypt).toHaveBeenCalledTimes(2); // Controller calls encrypt
        expect(User.prototype.save).toHaveBeenCalledTimes(1); // Controller calls save
    });

    it('should return 400 if user already exists via the route', async () => {
         const userData = { email: 'existing-route@example.com' };

        // Mock User.findOne to return an existing user object
        User.findOne.mockResolvedValue({ _id: 'existingRouteId', email: userData.email });

        const response = await request(app)
            .post('/api/users/register')
            .send(userData);

        // --- Assertions ---
        expect(response.statusCode).toBe(400);
        expect(response.body).toEqual({ message: 'User already exists' });

        // Verify database interaction
        expect(User.findOne).toHaveBeenCalledTimes(1);
        expect(User.findOne).toHaveBeenCalledWith({ email: userData.email });

        // Verify downstream functions were NOT called
        expect(bchService.generateAddress).not.toHaveBeenCalled();
        expect(cryptoUtils.encrypt).not.toHaveBeenCalled();
        expect(User.prototype.save).not.toHaveBeenCalled();
    });

    it('should return 400 if email is invalid via the route', async () => {
        const userData = { email: 'invalid-email' }; // Invalid email format

        const response = await request(app)
            .post('/api/users/register')
            .send(userData);

        // --- Assertions ---
        expect(response.statusCode).toBe(400);
        expect(response.body).toHaveProperty('errors');
        // This assertion depends on the actual validator message in userRoutes.js
        expect(response.body.errors[0]).toHaveProperty('msg', 'Invalid email format');
        expect(response.body.errors[0]).toHaveProperty('param', 'email');


        // Verify downstream functions were NOT called
        expect(User.findOne).not.toHaveBeenCalled();
        expect(bchService.generateAddress).not.toHaveBeenCalled();
        expect(User.prototype.save).not.toHaveBeenCalled();
    });

    // Add tests for the GET /recover-wallet route if needed,
    // ensuring authMiddleware is mocked appropriately.

});
